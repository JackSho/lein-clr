(ns leiningen.clr
  (:require [clojure.pprint  :as pp]
            [clojure.string  :as str]
            [clojure.java.io :as io]
            [leiningen.clr.internal   :as in]
            [leiningen.core.classpath :as lc])
  (:import (java.io Reader BufferedReader File InputStream InputStreamReader
                    OutputStream Writer)
           (java.util Map)))


(defn proj-key-cmd
  "Return a sequence of command and arguments"
  [proj-key default-value project]
  (or (when-let [cmd (get-in project proj-key)]
        (assert (vector? cmd)) (vec (map in/resolve-path cmd)))
      default-value))


(defn default-cmd
  [^String cmd] {:pre [(string? cmd)]}
  (let [^String os-name (System/getProperty "os.name")]
    (if (and os-name (.startsWith ^String os-name "Windows"))
      [cmd]
      ["mono" (or (in/which cmd) cmd)])))


(def clj-compile-cmd (partial proj-key-cmd [:clr :compile-cmd]
                              (default-cmd "Clojure.Compile.exe")))


(def clj-main-cmd (partial proj-key-cmd [:clr :main-cmd]
                           (default-cmd "Clojure.Main.exe")))


(defn all-load-paths
  [project]
  (->> (get-in project [:clr :load-paths])
       (map in/resolve-path)
       (concat (lc/get-classpath project))))


(defn assembly-search-paths
  [project]
  (->> (get-in project [:clr :assembly-paths])
       (map in/as-vector)
       (mapcat in/filter-assembly-paths)))


(defn asm-load-init
  [project init-file]
  (in/spit-assembly-load-instruction
    init-file
    (assembly-search-paths project))
  init-file)


(defn target-path
  [project]
  (or (get-in project [:clr :target-path])
      (str (:target-path project) File/separator "clr")))


(defn target-bin-path
  [project]
  (str (target-path project) File/separator "bin"))


(defn target-lib-path
  [project]
  (str (target-path project) File/separator "lib"))


;;; ========== Tasks ==========


(defn task-clean
  [project]
  (let [tp (target-path project)]
    (in/verbose "Recursively deleting directory: " tp)
    (in/rm-rf tp)))


(defn task-compile
  [project namespaces]
  (let [allp (all-load-paths project)
        srcp (concat (:source-paths project) (:test-paths project))
        nses (if (seq namespaces) namespaces (mapcat in/scan-namespaces srcp))
        exec (concat (clj-compile-cmd project) nses)]
    (in/with-process-builder pb (:root project) exec
      (in/configure-load-path (.environment ^ProcessBuilder pb) allp)
      (in/configure-compile-path (.environment ^ProcessBuilder pb)
                                 (target-bin-path project))
      (apply in/verbose "Running: " (map pr-str exec))
      (in/run-process pb))))


(defn task-help
  []
  (println "
Available tasks:
clean    delete files generated by lein-clr
compile  compile Clojure source into .dll, .exe and .pdb/.mdb files
help     show this help screen
repl     load a REPL with sources into CLOJURE_LOAD_PATH
run      run a namespace having `-main` function
test     run tests in specified/all test namespaces

Project configuration (in `project.clj`):
:clr {:compile-cmd [\"Clojure.Compile.exe\"] ; .NET default, Mono example below
      :main-cmd    [\"mono\" [CLJCLR14_PATH \"Clojure.Main.exe\"]]
      :assembly-paths [[\"ext/foo\" #\".*[Nn]et40.*\"]
                       \"ext/baaz\"]
      :load-paths  [CLJCLR14_40 NHIBERNATE_PATH]
      :target-path  \"path/to/clr-build/files\"}
"))


(defn task-repl
  [project]
  (let [init-file  (asm-load-init project (in/get-temp-file))
        allp (all-load-paths project)
        _    (in/verbose-init-with init-file)
        exec (concat (clj-main-cmd project) ["-i" init-file "-r"])]
    (in/with-process-builder pb (:root project) exec
      (in/configure-load-path (.environment ^ProcessBuilder pb) allp)
      (apply in/verbose "Running: " (map pr-str exec))
      (in/run-process pb :pipe-input))))


(def no-main "No :main namespace specified in project.clj.")
(def no-ns   "Option -m requires a namespace argument.")

(defn parse-run-args
  "Return a vector where first elem is the main ns, followed by remaining args"
  [project args]
  (let [proj-ns #(or (:main project) (in/exit-error 1 no-main))
        user-ns #(or (second args)   (in/exit-error 1 no-ns))]
    (cond
      (empty? args)         [(str (proj-ns))]
      (= (first args) "--") [(str (proj-ns)) (rest args)]
      (= (first args) "-m") [(user-ns) (nthrest args 2)]
      :otherwise            [(str (proj-ns)) args])))


(defn task-run
  [project args]
  (let [init-file  (asm-load-init project (in/get-temp-file))
        allp       (all-load-paths project)
        [rns args] (parse-run-args project args)
        _          (in/verbose-init-with init-file)
        r-ex       (concat (clj-main-cmd project) ["-i" init-file "-m" rns] args)]
    ;; run the namespace (r-ex)
    (in/with-process-builder pb (:root project) r-ex
      (in/configure-load-path (.environment ^ProcessBuilder pb) allp)
      (apply in/verbose "Running: " (map pr-str r-ex))
      (in/run-process pb))))


(defn task-test
  [project namespaces]
  (let [init-file (asm-load-init project (in/get-temp-file))
        allp (all-load-paths project)
        nses (mapcat in/scan-namespaces (:test-paths project))
        rtns (if (seq namespaces) namespaces nses)
        nstr (str/join " " (map (partial str "'") rtns))
        _    (in/spit-require-ns init-file rtns)
        _    (in/verbose-init-with init-file)
        expr (format "(use 'clojure.test) (run-tests %s)" nstr)
        exec (concat (clj-main-cmd project) ["-i" init-file "-e" expr])]
    ;; run the tests
    (in/with-process-builder pb (:root project) exec
      (in/configure-load-path (.environment ^ProcessBuilder pb) allp)
      (apply in/verbose "Running: " (map pr-str exec))
      (in/run-process pb))))


(defmacro try-pst
  [& body]
  `(try ~@body
     (catch Throwable t#
       (.printStackTrace t#))))


(defn clr
  "Automate build tasks for ClojureCLR projects

  For more information, run the below command:

  lein clr help"
  [project & [task & args]]
  (case task
    "clean"   (task-clean project)
    "compile" (task-compile project args)
    "help"    (task-help)
    "repl"    (try-pst (task-repl project))
    "run"     (try-pst (task-run  project args))
    "test"    (try-pst (task-test project args))
    "-v"      (binding [in/*verbose* true] (apply clr project args))
    (do (println "No such task: " (pr-str task))
        (task-help))))