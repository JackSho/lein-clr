(ns leiningen.clr
  (:require [clojure.pprint  :as pp]
            [clojure.string  :as str]
            [clojure.java.io :as io]
            [leiningen.clr.internal :as in])
  (:import (java.io Reader BufferedReader File InputStream InputStreamReader
                    OutputStream Writer)
           (java.util Map)))


(defn proj-key-cmd
  "Return a sequence of command and arguments"
  [proj-key default-value project]
  (or (when-let [cmd (get-in project proj-key)]
        (assert (vector? cmd)) (vec (map in/resolve-path cmd)))
      default-value))


(defn default-cmd
  [^String cmd] {:pre [(string? cmd)]}
  (let [^String os-name (System/getProperty "os.name")]
    (if (and os-name (.startsWith ^String os-name "Windows"))
      [cmd]
      ["mono" (or (in/which cmd) cmd)])))


(def clj-compile-cmd (partial proj-key-cmd [:clr :compile-cmd]
                              (default-cmd "Clojure.Compile.exe")))


(def clj-main-cmd (partial proj-key-cmd [:clr :main-cmd]
                           (default-cmd "Clojure.Main.exe")))


(defn all-paths
  [project]
  (->> (get-in project [:clr :load-paths])
       (map in/resolve-path)
       (concat (mapcat project [:source-paths :resource-paths :test-paths]))))


(defn target-path
  [project]
  (or (get-in project [:clr :target-path])
      (str (:target-path project) File/separator "clr")))


(defn task-clean
  [project]
  (let [tp (target-path project)]
    (in/verbose "Recursively deleting directory: " tp)
    (in/rm-rf tp)))


(defn task-compile
  [project namespaces]
  (let [allp (all-paths project)
        srcp (concat (:source-paths project) (:test-paths project))
        nses (if (seq namespaces) namespaces (mapcat in/scan-namespaces srcp))
        exec (concat (clj-compile-cmd project) nses)]
    (in/with-process-builder pb (:root project) exec
      (in/configure-load-path (.environment ^ProcessBuilder pb) allp)
      (in/configure-compile-path (.environment ^ProcessBuilder pb)
                                 (target-path project))
      (apply in/verbose "Running: " (map pr-str exec))
      (in/run-process pb))))


(defn task-help
  []
  (println "
Available tasks:
clean    delete files generated by lein-clr
compile  compile Clojure source into .pdb and .dll files
help     show this help screen
repl     load a REPL with sources into CLOJURE_LOAD_PATH
run      run a namespace having `-main` function
test     run tests in specified/all test namespaces

Project configuration (in `project.clj`):
:clr {:compile-cmd [\"Clojure.Compile.exe\"] ; .NET default, Mono example below
      :main-cmd    [\"mono\" [CLJCLR14_PATH \"Clojure.Main.exe\"]]
      :load-paths  [CLJCLR14_40 NHIBERNATE_PATH]
      :target-path \"path/to/compiled/files\"}
"))


(defn task-repl
  [project]
  (let [allp (all-paths project)
        exec (clj-main-cmd project)]
    (in/with-process-builder pb (:root project) exec
      (in/configure-load-path (.environment ^ProcessBuilder pb) allp)
      (apply in/verbose "Running: " (map pr-str exec))
      (in/run-process pb :pipe-input))))


(def no-main "No :main namespace specified in project.clj.")
(def no-ns   "Option -m requires a namespace argument.")

(defn parse-run-args
  "Return a vector where first elem is the main ns, followed by remaining args"
  [project args]
  (let [proj-ns #(or (:main project) (in/exit-error 1 no-main))
        user-ns #(or (second args)   (in/exit-error 1 no-ns))]
    (cond
      (empty? args)         [(str (proj-ns))]
      (= (first args) "--") [(str (proj-ns)) (rest args)]
      (= (first args) "-m") [(user-ns) (nthrest args 2)]
      :otherwise            [(str (proj-ns)) args])))


(defn task-run
  [project args]
  (let [allp       (all-paths project)
        [rns args] (parse-run-args project args)
        r-ex       (concat (clj-main-cmd project) ["-m" rns] args)]
    ;; run the namespace (r-ex)
    (in/with-process-builder pb (:root project) r-ex
      (in/configure-load-path (.environment ^ProcessBuilder pb) allp)
      (apply in/verbose "Running: " (map pr-str r-ex))
      (in/run-process pb))))


(defn task-test
  [project namespaces]
  (let [allp (all-paths project)
        nses (mapcat in/scan-namespaces (:test-paths project))
        rtns (if (seq namespaces) namespaces nses)
        nstr (str/join " " (map (partial str "'") rtns))
        expr (format "(use 'clojure.test) %s (run-tests %s)"
                     (when (seq rtns) (str "(require " nstr ")"))
                     nstr)
        exec (concat (clj-main-cmd project) ["-e" expr])]
    ;; run the tests
    (in/with-process-builder pb (:root project) exec
      (in/configure-load-path (.environment ^ProcessBuilder pb) allp)
      (apply in/verbose "Running: " (map pr-str exec))
      (in/run-process pb))))


(defn clr
  "Automate build tasks for ClojureCLR projects

  For more information, run the below command:

  lein clr help"
  [project & [task & args]]
  (case task
    "clean"   (task-clean project)
    "compile" (task-compile project args)
    "help"    (task-help)
    "repl"    (task-repl project)
    "run"     (task-run  project args)
    "test"    (task-test project args)
    "-v"      (binding [in/*verbose* true] (apply clr project args))
    (do (println "No such task: " (pr-str task))
        (task-help))))